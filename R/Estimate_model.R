#' Estimate the parametric age-reading error matrix
#'
#' @param data a data frame containing the columns modal_age_closest, modal_age_low, age, corresponding to the modal age closest to the mean, the lowest modal age, and an age-reading, respectively. No ages are lower than min_age, and no ages are higher than max_age. Typically the output generated by the function Cap_ages.
#' @param min_age Integer, the minimum age
#' @param max_age Integer, the maximum age
#' @param start Numerical vector with length 5. Starting values for the parameters in the order beta0, beta1, alpha0, alpha1, phi.
#' @param estimate Vector of length 5 with indicators for whether each parameter should be estimated (1) or fixed (0). Defaults to estimating all parameters.
#' @param lowmode Indicator for whether we should use the lowest modal age (1). Default is to use the modal age closest to the mean (0).
#'
#' @return a list with par_est: the estimated parameters and corresponding standard deviations, Sigma: the covariance matrix for the estimated parameters, loglik: the log likelihood
#' @export
#'
#' @examples
#' file_path = system.file("extdata",
#'                         "NSS_herring_scales.csv",
#'                          package = "ParametricAEM")
#' data_nss_scales = read.csv(file_path, sep = ",")
#' data_exp = data_nss_scales[data_nss_scales$expertise == 1, ] # Extract experts
#' data_exp = data_exp[data_exp$age > 0, ]
#' data_analysis = Compute_modes(data_exp)
#' data_analysis_capped = Cap_ages(data_analysis)
#' fit = Estimate_model(data = data_analysis_capped,
#'                      min_age = 3,
#'                      max_age = 12,
#'                      start = c(2, 0, 0, 0, 0.2),
#'                      estimate = c(1, 1, 0, 0, 1))
Estimate_model = function(data, min_age, max_age, start = c(2, 0, 0.5, 0, 0.2), estimate = rep(1, 5), lowmode = FALSE){
    par.all = as.matrix(t(data.frame("beta0" = c(start[1], estimate[1]),
                         "beta1" = c(start[2], estimate[2]),
                         "alpha0" = c(start[3], estimate[3]),
                         "alpha1" = c(start[4], estimate[4]),
                         "phi" = c(start[5], estimate[5]))))
    colnames(par.all) = c("value", "est")
    par.est<-par.all[par.all[,"est"]==TRUE,,drop=F]
    par.fixed<-par.all[par.all[,"est"]==FALSE,,drop=F]
    parnames = c(rownames(par.est), rownames(par.fixed))
    par.est = par.est[,"value"]
    par.fixed = par.fixed[,"value"]
    fit = stats::nlminb(par.est, negloglik, data = data, par.fixed = par.fixed, min_age = min_age, max_age = max_age, parnames = parnames, lowmode = lowmode)
    results = list()
    Sigma = solve(numDeriv::hessian(negloglik, x = fit$par, data = data, par.fixed = par.fixed, min_age = min_age, max_age = max_age, parnames = parnames, lowmode = lowmode))
    sds = round(sqrt(diag(Sigma)), 7)
    loglik = -fit$objective
    results$loglik = loglik
    results$Sigma = Sigma
    par_est = cbind(fit$par, sds)
    colnames(par_est) = c("Estimate", "Std.dev")
    results$estimate = par_est
    return(results)
}

#' Negative log likelihood. This function is called by Estimate_model.
#'
#' @param param Numerical vector with values for parameters that are estimated
#' @param data a data frame containing the columns modal_age_closest, modal_age_low, age, corresponding to the modal age closest to the mean, the lowest modal age, and an age-reading, respectively. No ages are lower than min_age, and no ages are higher than max_age. Typically the output generated by the function Cap_ages.
#' @param par.fixed Numerical vector of values for fixed parameters
#' @param min_age Integer, the minimum age
#' @param max_age Integer, the maximum age
#' @param parnames Vector of all parameter names in the order: estimated parameters, fixed parameters
#' @param lowmode Indicator for whether we should use the lowest modal age (1). Default is to use the modal age closest to the mean (0).
#'
#' @return Float, the negative log likelihood
negloglik = function(param, data, par.fixed, min_age, max_age, parnames, lowmode){
    par = c(param, par.fixed)
    names(par) = parnames
    return(-loglik(par, min_age = min_age, max_age = max_age, data = data, lowmode = lowmode))
}

#' Title
#'
#' @param theta Numerical vector with values for the estimated parameters
#' @param min_age The minimum age
#' @param max_age The maximum age
#' @param data a data frame containing the columns modal_age_closest, modal_age_low, age, corresponding to the modal age closest to the mean, the lowest modal age, and an age-reading, respectively. No ages are lower than min_age, and no ages are higher than max_age. Typically the output generated by the function Cap_ages.
#' @param lowmode Indicator for whether we should use the lowest modal age (1).
#'
#' @return Float, the likelihood
#'
loglik = function(theta, min_age, max_age, data, lowmode){
    beta0 = theta["beta0"]
    beta1 = theta["beta1"]
    alpha0 = theta["alpha0"]
    alpha1 = theta["alpha1"]
    phi = theta["phi"]
    if(lowmode == TRUE){
        true_age = data$modal_age_low
    }
    else{
        true_age = data$modal_age_closest
    }
    age = data$age
    weight = data$weight
    totLik = 0
    # See paper for definition of parametric matrix
    for(i in 1:length(true_age)){
        paa = exp(beta0 + beta1 * true_age[i]) / (1 + exp(beta0 + beta1 * true_age[i]))
        qa = exp(alpha0 + alpha1 * true_age[i]) / (1 + exp(alpha0 + alpha1 * true_age[i]))
        if(true_age[i] == age[i]){
            if(true_age[i] == max_age){
                p = qa + paa - paa * qa
            } else if(true_age[i] == min_age){
                p = 1 - qa + paa * qa
            }else{
                p = paa
            }
        }
        else if(age[i] > true_age[i]){
            if(age[i] == max_age){
                p = (1 - paa) * qa * phi ^ (max_age - true_age[i] - 1)
            }else{
                p = (1 - paa) * qa * (1 - phi) * phi ^ (age[i] - 1 - true_age[i])
            }
        }
        else{
            d = true_age[i] - min_age
            p = (1 - paa) * (1 - qa) * phi ^ (true_age[i] - age[i] - 1) * (1 - phi) / (1 - phi ^ (d))
        }

        totLik = totLik + weight[i] * log(p)
    }
    return(totLik)
}
